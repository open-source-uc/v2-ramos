---
title: "Node.js y Express: API REST desde Cero"
readtime: 14
description: "Aprende a construir una API REST completa con Node.js y Express. Incluye autenticaci√≥n, validaci√≥n, conexi√≥n a base de datos y mejores pr√°cticas de seguridad."
author:
  name: "Roberto Silva"
  title: "Backend Developer & DevOps Engineer"
  picture: "https://images.unsplash.com/photo-1519085360753-af0119f7cbe7?w=150&h=150&fit=crop&crop=face"
  link: "https://github.com/robertosilva"
tags:
  - nodejs
  - express
  - api
  - backend
  - rest
  - javascript
---

# Node.js y Express: API REST desde Cero

Node.js se ha convertido en una de las tecnolog√≠as m√°s populares para el desarrollo backend. En este tutorial, construiremos una API REST completa desde cero, cubriendo desde la configuraci√≥n inicial hasta el despliegue.

## ¬øQu√© vamos a construir?

Crearemos una API para gestionar una biblioteca digital con las siguientes funcionalidades:
- Gesti√≥n de usuarios (registro, login, perfiles)
- CRUD de libros
- Sistema de pr√©stamos
- Autenticaci√≥n con JWT
- Validaci√≥n de datos
- Conexi√≥n a MongoDB

## Configuraci√≥n Inicial

### Inicializar el proyecto
```bash
mkdir biblioteca-api
cd biblioteca-api
npm init -y

# Instalar dependencias principales
npm install express mongoose bcryptjs jsonwebtoken cors helmet dotenv

# Dependencias de desarrollo
npm install --save-dev nodemon
```

### Estructura del proyecto
```
biblioteca-api/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ server.js
```

### Configuraci√≥n b√°sica (server.js)
```javascript
const app = require('./src/app');
const mongoose = require('mongoose');
require('dotenv').config();

const PORT = process.env.PORT || 3000;
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/biblioteca';

// Conectar a MongoDB
mongoose.connect(MONGODB_URI)
  .then(() => {
    console.log('‚úÖ Conectado a MongoDB');
    app.listen(PORT, () => {
      console.log(`üöÄ Servidor ejecut√°ndose en puerto ${PORT}`);
    });
  })
  .catch((error) => {
    console.error('‚ùå Error conectando a MongoDB:', error);
    process.exit(1);
  });
```

### Configuraci√≥n de Express (src/app.js)
```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');

// Importar rutas
const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const bookRoutes = require('./routes/books');
const loanRoutes = require('./routes/loans');

// Middleware personalizado
const errorHandler = require('./middleware/errorHandler');
const notFound = require('./middleware/notFound');

const app = express();

// Middleware de seguridad
app.use(helmet());
app.use(cors());

// Middleware para parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Logging middleware
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

// Rutas
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/books', bookRoutes);
app.use('/api/loans', loanRoutes);

// Ruta de salud
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Middleware de manejo de errores
app.use(notFound);
app.use(errorHandler);

module.exports = app;
```

## Modelos de Datos

### Modelo de Usuario (src/models/User.js)
```javascript
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  nombre: {
    type: String,
    required: [true, 'El nombre es requerido'],
    trim: true,
    maxlength: [50, 'El nombre no puede exceder 50 caracteres']
  },
  email: {
    type: String,
    required: [true, 'El email es requerido'],
    unique: true,
    lowercase: true,
    match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Email inv√°lido']
  },
  password: {
    type: String,
    required: [true, 'La contrase√±a es requerida'],
    minlength: [6, 'La contrase√±a debe tener al menos 6 caracteres']
  },
  rol: {
    type: String,
    enum: ['usuario', 'bibliotecario', 'admin'],
    default: 'usuario'
  },
  activo: {
    type: Boolean,
    default: true
  },
  fechaRegistro: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true,
  toJSON: { 
    transform: function(doc, ret) {
      delete ret.password;
      return ret;
    }
  }
});

// Middleware para hashear password antes de guardar
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(12);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// M√©todo para comparar passwords
userSchema.methods.compararPassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

module.exports = mongoose.model('User', userSchema);
```

### Modelo de Libro (src/models/Book.js)
```javascript
const mongoose = require('mongoose');

const bookSchema = new mongoose.Schema({
  titulo: {
    type: String,
    required: [true, 'El t√≠tulo es requerido'],
    trim: true,
    maxlength: [200, 'El t√≠tulo no puede exceder 200 caracteres']
  },
  autor: {
    type: String,
    required: [true, 'El autor es requerido'],
    trim: true,
    maxlength: [100, 'El autor no puede exceder 100 caracteres']
  },
  isbn: {
    type: String,
    required: [true, 'El ISBN es requerido'],
    unique: true,
    match: [/^(?:ISBN(?:-1[03])?:?\s)?(?=[-0-9\s]{17}$|[-0-9X\s]{13}$|[0-9X]{10}$)(?:97[89][-\s]?)?[0-9]{1,5}[-\s]?(?:[0-9]+[-\s]?){2}[0-9X]$/, 'ISBN inv√°lido']
  },
  genero: {
    type: String,
    required: [true, 'El g√©nero es requerido'],
    enum: ['ficcion', 'no-ficcion', 'ciencia', 'historia', 'biografia', 'tecnologia', 'arte', 'otro']
  },
  fechaPublicacion: {
    type: Date,
    required: [true, 'La fecha de publicaci√≥n es requerida']
  },
  editorial: {
    type: String,
    required: [true, 'La editorial es requerida'],
    trim: true
  },
  paginas: {
    type: Number,
    required: [true, 'El n√∫mero de p√°ginas es requerido'],
    min: [1, 'El n√∫mero de p√°ginas debe ser mayor a 0']
  },
  disponible: {
    type: Boolean,
    default: true
  },
  descripcion: {
    type: String,
    maxlength: [1000, 'La descripci√≥n no puede exceder 1000 caracteres']
  },
  portada: {
    type: String, // URL de la imagen
    default: null
  }
}, {
  timestamps: true
});

// √çndices para b√∫squedas eficientes
bookSchema.index({ titulo: 'text', autor: 'text', descripcion: 'text' });
bookSchema.index({ genero: 1 });
bookSchema.index({ disponible: 1 });

module.exports = mongoose.model('Book', bookSchema);
```

## Controladores

### Controlador de Autenticaci√≥n (src/controllers/authController.js)
```javascript
const User = require('../models/User');
const jwt = require('jsonwebtoken');
const { validationResult } = require('express-validator');

// Generar JWT
const generarToken = (userId) => {
  return jwt.sign({ userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '7d'
  });
};

// Registro de usuario
exports.registro = async (req, res) => {
  try {
    // Verificar errores de validaci√≥n
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Errores de validaci√≥n',
        errors: errors.array()
      });
    }

    const { nombre, email, password } = req.body;

    // Verificar si el usuario ya existe
    const usuarioExistente = await User.findOne({ email });
    if (usuarioExistente) {
      return res.status(400).json({
        success: false,
        message: 'El usuario ya existe con este email'
      });
    }

    // Crear nuevo usuario
    const usuario = new User({ nombre, email, password });
    await usuario.save();

    // Generar token
    const token = generarToken(usuario._id);

    res.status(201).json({
      success: true,
      message: 'Usuario registrado exitosamente',
      data: {
        usuario,
        token
      }
    });

  } catch (error) {
    console.error('Error en registro:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Login de usuario
exports.login = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Errores de validaci√≥n',
        errors: errors.array()
      });
    }

    const { email, password } = req.body;

    // Buscar usuario por email
    const usuario = await User.findOne({ email }).select('+password');
    if (!usuario) {
      return res.status(401).json({
        success: false,
        message: 'Credenciales inv√°lidas'
      });
    }

    // Verificar contrase√±a
    const passwordValido = await usuario.compararPassword(password);
    if (!passwordValido) {
      return res.status(401).json({
        success: false,
        message: 'Credenciales inv√°lidas'
      });
    }

    // Verificar si el usuario est√° activo
    if (!usuario.activo) {
      return res.status(401).json({
        success: false,
        message: 'Cuenta desactivada'
      });
    }

    // Generar token
    const token = generarToken(usuario._id);

    res.json({
      success: true,
      message: 'Login exitoso',
      data: {
        usuario: {
          id: usuario._id,
          nombre: usuario.nombre,
          email: usuario.email,
          rol: usuario.rol
        },
        token
      }
    });

  } catch (error) {
    console.error('Error en login:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Obtener perfil del usuario actual
exports.perfil = async (req, res) => {
  try {
    const usuario = await User.findById(req.usuario.id);
    
    res.json({
      success: true,
      data: { usuario }
    });

  } catch (error) {
    console.error('Error obteniendo perfil:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};
```

### Controlador de Libros (src/controllers/bookController.js)
```javascript
const Book = require('../models/Book');
const { validationResult } = require('express-validator');

// Obtener todos los libros con paginaci√≥n y filtros
exports.obtenerLibros = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    // Construir filtros
    const filtros = {};
    
    if (req.query.genero) {
      filtros.genero = req.query.genero;
    }
    
    if (req.query.disponible !== undefined) {
      filtros.disponible = req.query.disponible === 'true';
    }
    
    if (req.query.buscar) {
      filtros.$text = { $search: req.query.buscar };
    }

    // Ejecutar consulta
    const libros = await Book.find(filtros)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const total = await Book.countDocuments(filtros);

    res.json({
      success: true,
      data: {
        libros,
        paginacion: {
          paginaActual: page,
          totalPaginas: Math.ceil(total / limit),
          totalLibros: total,
          librosPorPagina: limit
        }
      }
    });

  } catch (error) {
    console.error('Error obteniendo libros:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Crear nuevo libro
exports.crearLibro = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Errores de validaci√≥n',
        errors: errors.array()
      });
    }

    const libro = new Book(req.body);
    await libro.save();

    res.status(201).json({
      success: true,
      message: 'Libro creado exitosamente',
      data: { libro }
    });

  } catch (error) {
    console.error('Error creando libro:', error);
    
    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe un libro con ese ISBN'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Obtener libro por ID
exports.obtenerLibroPorId = async (req, res) => {
  try {
    const libro = await Book.findById(req.params.id);
    
    if (!libro) {
      return res.status(404).json({
        success: false,
        message: 'Libro no encontrado'
      });
    }

    res.json({
      success: true,
      data: { libro }
    });

  } catch (error) {
    console.error('Error obteniendo libro:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Actualizar libro
exports.actualizarLibro = async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Errores de validaci√≥n',
        errors: errors.array()
      });
    }

    const libro = await Book.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    );

    if (!libro) {
      return res.status(404).json({
        success: false,
        message: 'Libro no encontrado'
      });
    }

    res.json({
      success: true,
      message: 'Libro actualizado exitosamente',
      data: { libro }
    });

  } catch (error) {
    console.error('Error actualizando libro:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};

// Eliminar libro
exports.eliminarLibro = async (req, res) => {
  try {
    const libro = await Book.findByIdAndDelete(req.params.id);

    if (!libro) {
      return res.status(404).json({
        success: false,
        message: 'Libro no encontrado'
      });
    }

    res.json({
      success: true,
      message: 'Libro eliminado exitosamente'
    });

  } catch (error) {
    console.error('Error eliminando libro:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
};
```

## Middleware

### Middleware de Autenticaci√≥n (src/middleware/auth.js)
```javascript
const jwt = require('jsonwebtoken');
const User = require('../models/User');

exports.verificarToken = async (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'Token de acceso requerido'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const usuario = await User.findById(decoded.userId);

    if (!usuario || !usuario.activo) {
      return res.status(401).json({
        success: false,
        message: 'Token inv√°lido'
      });
    }

    req.usuario = { id: usuario._id, rol: usuario.rol };
    next();

  } catch (error) {
    console.error('Error verificando token:', error);
    res.status(401).json({
      success: false,
      message: 'Token inv√°lido'
    });
  }
};

exports.verificarRol = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.usuario.rol)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para realizar esta acci√≥n'
      });
    }
    next();
  };
};
```

### Middleware de Manejo de Errores (src/middleware/errorHandler.js)
```javascript
const errorHandler = (err, req, res, next) => {
  console.error('Error capturado:', err);

  // Error de validaci√≥n de Mongoose
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(e => e.message);
    return res.status(400).json({
      success: false,
      message: 'Error de validaci√≥n',
      errors
    });
  }

  // Error de duplicado (√≠ndice √∫nico)
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue)[0];
    return res.status(400).json({
      success: false,
      message: `Ya existe un registro con ese ${field}`
    });
  }

  // Error de JWT
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      message: 'Token inv√°lido'
    });
  }

  // Error por defecto
  res.status(500).json({
    success: false,
    message: 'Error interno del servidor'
  });
};

module.exports = errorHandler;
```

## Rutas

### Rutas de Autenticaci√≥n (src/routes/auth.js)
```javascript
const express = require('express');
const { body } = require('express-validator');
const authController = require('../controllers/authController');
const { verificarToken } = require('../middleware/auth');

const router = express.Router();

// Validaciones
const validacionRegistro = [
  body('nombre')
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('El nombre debe tener entre 2 y 50 caracteres'),
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Email inv√°lido'),
  body('password')
    .isLength({ min: 6 })
    .withMessage('La contrase√±a debe tener al menos 6 caracteres')
];

const validacionLogin = [
  body('email')
    .isEmail()
    .normalizeEmail()
    .withMessage('Email inv√°lido'),
  body('password')
    .notEmpty()
    .withMessage('La contrase√±a es requerida')
];

// Rutas p√∫blicas
router.post('/registro', validacionRegistro, authController.registro);
router.post('/login', validacionLogin, authController.login);

// Rutas protegidas
router.get('/perfil', verificarToken, authController.perfil);

module.exports = router;
```

## Variables de Entorno (.env)
```env
# Servidor
PORT=3000
NODE_ENV=development

# Base de datos
MONGODB_URI=mongodb://localhost:27017/biblioteca

# JWT
JWT_SECRET=tu_secret_super_seguro_aqui
JWT_EXPIRES_IN=7d

# Otros
BCRYPT_ROUNDS=12
```

## Scripts de Package.json
```json
{
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix"
  }
}
```

## Mejores Pr√°cticas Implementadas

### 1. Seguridad
- Validaci√≥n y sanitizaci√≥n de datos
- Hashing de contrase√±as con bcrypt
- Autenticaci√≥n con JWT
- Middleware de seguridad con Helmet
- Rate limiting (recomendado para producci√≥n)

### 2. Estructura del C√≥digo
- Separaci√≥n clara de responsabilidades
- Middleware reutilizable
- Manejo centralizado de errores
- Validaciones consistentes

### 3. Base de Datos
- Modelos bien definidos con validaciones
- √çndices para optimizar consultas
- Paginaci√≥n para grandes datasets

### 4. API Design
- Respuestas consistentes
- C√≥digos de estado HTTP apropiados
- Documentaci√≥n impl√≠cita en los controladores

## Conclusi√≥n

Hemos construido una API REST robusta y escalable usando Node.js y Express. Esta base s√≥lida incluye autenticaci√≥n, validaci√≥n, manejo de errores y buenas pr√°cticas de seguridad.

**Pr√≥ximos pasos recomendados:**
1. A√±adir tests unitarios y de integraci√≥n
2. Implementar rate limiting
3. A√±adir logging avanzado
4. Documentar la API con Swagger
5. Implementar caching con Redis
6. Configurar CI/CD para despliegue

¬°Con esta base puedes expandir la API seg√∫n tus necesidades espec√≠ficas!
