---
title: "React Hooks: Guía Práctica de los Hooks Más Utilizados"
readtime: 10
description: "Domina los React Hooks esenciales con ejemplos prácticos. Desde useState hasta hooks personalizados, aprende a escribir componentes funcionales más efectivos."
author:
  name: "Sofía Chen"
  title: "React Developer"
  picture: "https://images.unsplash.com/photo-1438761681033-6461ffad8d80?w=150&h=150&fit=crop&crop=face"
  link: "https://github.com/sofiachen"
tags:
  - react
  - hooks
  - javascript
  - frontend
  - desarrollo-web
---

# React Hooks: Guía Práctica de los Hooks Más Utilizados

Los React Hooks revolucionaron la forma en que escribimos componentes en React. Te permiten usar el estado y otras características de React sin escribir clases, haciendo el código más simple y reutilizable.

## 1. useState: Manejando el Estado Local

El hook más básico y fundamental para manejar estado en componentes funcionales.

```jsx
import React, { useState } from 'react';

function Contador() {
  const [contador, setContador] = useState(0);

  return (
    <div>
      <p>Has hecho clic {contador} veces</p>
      <button onClick={() => setContador(contador + 1)}>
        Incrementar
      </button>
      <button onClick={() => setContador(0)}>
        Reiniciar
      </button>
    </div>
  );
}
```

### Trabajando con Objetos y Arrays

```jsx
function FormularioUsuario() {
  const [usuario, setUsuario] = useState({
    nombre: '',
    email: '',
    edad: 0
  });

  const actualizarCampo = (campo, valor) => {
    setUsuario(prevUsuario => ({
      ...prevUsuario,
      [campo]: valor
    }));
  };

  return (
    <form>
      <input
        type="text"
        value={usuario.nombre}
        onChange={(e) => actualizarCampo('nombre', e.target.value)}
        placeholder="Nombre"
      />
      <input
        type="email"
        value={usuario.email}
        onChange={(e) => actualizarCampo('email', e.target.value)}
        placeholder="Email"
      />
    </form>
  );
}
```

## 2. useEffect: Efectos Secundarios

Maneja efectos secundarios como llamadas a APIs, suscripciones, o manipulación del DOM.

```jsx
import React, { useState, useEffect } from 'react';

function UsuarioProfile({ usuarioId }) {
  const [usuario, setUsuario] = useState(null);
  const [cargando, setCargando] = useState(true);

  useEffect(() => {
    const cargarUsuario = async () => {
      setCargando(true);
      try {
        const response = await fetch(`/api/usuarios/${usuarioId}`);
        const userData = await response.json();
        setUsuario(userData);
      } catch (error) {
        console.error('Error cargando usuario:', error);
      } finally {
        setCargando(false);
      }
    };

    cargarUsuario();
  }, [usuarioId]); // Se ejecuta cuando usuarioId cambia

  if (cargando) return <div>Cargando...</div>;
  if (!usuario) return <div>Usuario no encontrado</div>;

  return (
    <div>
      <h2>{usuario.nombre}</h2>
      <p>{usuario.email}</p>
    </div>
  );
}
```

### Limpieza de Efectos

```jsx
function Timer() {
  const [segundos, setSegundos] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSegundos(prev => prev + 1);
    }, 1000);

    // Función de limpieza
    return () => {
      clearInterval(interval);
    };
  }, []); // Array vacío = se ejecuta solo una vez

  return <div>Tiempo transcurrido: {segundos} segundos</div>;
}
```

## 3. useContext: Compartiendo Estado Global

Evita el "prop drilling" permitiendo acceso directo a datos del contexto.

```jsx
import React, { createContext, useContext, useState } from 'react';

// Crear el contexto
const TemaContext = createContext();

// Provider del contexto
function TemaProvider({ children }) {
  const [tema, setTema] = useState('claro');

  const toggleTema = () => {
    setTema(prev => prev === 'claro' ? 'oscuro' : 'claro');
  };

  return (
    <TemaContext.Provider value={{ tema, toggleTema }}>
      {children}
    </TemaContext.Provider>
  );
}

// Hook personalizado para usar el contexto
function useTema() {
  const contexto = useContext(TemaContext);
  if (!contexto) {
    throw new Error('useTema debe usarse dentro de TemaProvider');
  }
  return contexto;
}

// Componente que usa el contexto
function BotonTema() {
  const { tema, toggleTema } = useTema();

  return (
    <button
      onClick={toggleTema}
      style={{
        backgroundColor: tema === 'claro' ? '#fff' : '#333',
        color: tema === 'claro' ? '#333' : '#fff'
      }}
    >
      Cambiar a tema {tema === 'claro' ? 'oscuro' : 'claro'}
    </button>
  );
}
```

## 4. useReducer: Estado Complejo

Para manejar estado complejo con múltiples acciones.

```jsx
import React, { useReducer } from 'react';

// Reducer function
function contadorReducer(state, action) {
  switch (action.type) {
    case 'incrementar':
      return { ...state, valor: state.valor + 1 };
    case 'decrementar':
      return { ...state, valor: state.valor - 1 };
    case 'reiniciar':
      return { ...state, valor: 0 };
    case 'establecer':
      return { ...state, valor: action.payload };
    default:
      throw new Error(`Acción no reconocida: ${action.type}`);
  }
}

function ContadorAvanzado() {
  const [state, dispatch] = useReducer(contadorReducer, { valor: 0 });

  return (
    <div>
      <p>Contador: {state.valor}</p>
      <button onClick={() => dispatch({ type: 'incrementar' })}>
        +1
      </button>
      <button onClick={() => dispatch({ type: 'decrementar' })}>
        -1
      </button>
      <button onClick={() => dispatch({ type: 'reiniciar' })}>
        Reiniciar
      </button>
      <button onClick={() => dispatch({ type: 'establecer', payload: 100 })}>
        Establecer en 100
      </button>
    </div>
  );
}
```

## 5. useMemo: Optimización de Cálculos

Memoriza resultados de cálculos costosos.

```jsx
import React, { useState, useMemo } from 'react';

function ListaUsuarios({ usuarios }) {
  const [filtro, setFiltro] = useState('');

  // Cálculo costoso que solo se ejecuta si usuarios o filtro cambian
  const usuariosFiltrados = useMemo(() => {
    console.log('Filtrando usuarios...');
    return usuarios.filter(usuario =>
      usuario.nombre.toLowerCase().includes(filtro.toLowerCase())
    );
  }, [usuarios, filtro]);

  const estadisticas = useMemo(() => {
    return {
      total: usuarios.length,
      filtrados: usuariosFiltrados.length,
      porcentaje: ((usuariosFiltrados.length / usuarios.length) * 100).toFixed(1)
    };
  }, [usuarios.length, usuariosFiltrados.length]);

  return (
    <div>
      <input
        type="text"
        value={filtro}
        onChange={(e) => setFiltro(e.target.value)}
        placeholder="Filtrar usuarios..."
      />
      <p>
        Mostrando {estadisticas.filtrados} de {estadisticas.total} usuarios 
        ({estadisticas.porcentaje}%)
      </p>
      <ul>
        {usuariosFiltrados.map(usuario => (
          <li key={usuario.id}>{usuario.nombre}</li>
        ))}
      </ul>
    </div>
  );
}
```

## 6. useCallback: Optimización de Funciones

Memoriza funciones para evitar recreaciones innecesarias.

```jsx
import React, { useState, useCallback, memo } from 'react';

// Componente hijo memorizado
const BotonMemo = memo(({ onClick, children }) => {
  console.log('BotonMemo renderizado');
  return <button onClick={onClick}>{children}</button>;
});

function ComponentePadre() {
  const [contador, setContador] = useState(0);
  const [otro, setOtro] = useState(0);

  // Sin useCallback, esta función se recrea en cada render
  const incrementarContador = useCallback(() => {
    setContador(prev => prev + 1);
  }, []); // No depende de ningún valor

  const incrementarOtro = useCallback(() => {
    setOtro(prev => prev + 1);
  }, []);

  return (
    <div>
      <p>Contador: {contador}</p>
      <p>Otro: {otro}</p>
      
      {/* Este botón no se re-renderiza innecesariamente */}
      <BotonMemo onClick={incrementarContador}>
        Incrementar Contador
      </BotonMemo>
      
      <BotonMemo onClick={incrementarOtro}>
        Incrementar Otro
      </BotonMemo>
    </div>
  );
}
```

## 7. useRef: Referencias Directas

Accede directamente a elementos del DOM o mantén valores mutables.

```jsx
import React, { useRef, useState, useEffect } from 'react';

function EjemplosUseRef() {
  const inputRef = useRef(null);
  const contadorRenders = useRef(0);
  const [, forceUpdate] = useState({});

  // Contar renders sin causar re-renders
  useEffect(() => {
    contadorRenders.current += 1;
  });

  const enfocarInput = () => {
    inputRef.current?.focus();
  };

  const limpiarInput = () => {
    if (inputRef.current) {
      inputRef.current.value = '';
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <p>Este componente se ha renderizado {contadorRenders.current} veces</p>
      
      <input
        ref={inputRef}
        type="text"
        placeholder="Escribe algo..."
      />
      
      <button onClick={enfocarInput}>Enfocar Input</button>
      <button onClick={limpiarInput}>Limpiar y Enfocar</button>
      <button onClick={() => forceUpdate({})}>Forzar Re-render</button>
    </div>
  );
}
```

## 8. Hook Personalizado: Reutilización de Lógica

Crea tus propios hooks para compartir lógica entre componentes.

```jsx
import { useState, useEffect } from 'react';

// Hook personalizado para llamadas a API
function useApi(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const cargarDatos = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Error: ${response.status}`);
        }
        
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    if (url) {
      cargarDatos();
    }
  }, [url]);

  return { data, loading, error };
}

// Hook para localStorage
function useLocalStorage(key, valorInicial) {
  const [valor, setValor] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : valorInicial;
    } catch (error) {
      console.error(`Error leyendo localStorage key "${key}":`, error);
      return valorInicial;
    }
  });

  const setValue = (nuevoValor) => {
    try {
      setValor(nuevoValor);
      window.localStorage.setItem(key, JSON.stringify(nuevoValor));
    } catch (error) {
      console.error(`Error guardando en localStorage key "${key}":`, error);
    }
  };

  return [valor, setValue];
}

// Usando los hooks personalizados
function ComponenteEjemplo() {
  const { data: usuarios, loading, error } = useApi('/api/usuarios');
  const [favoritos, setFavoritos] = useLocalStorage('usuarios-favoritos', []);

  if (loading) return <div>Cargando...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h2>Usuarios ({usuarios?.length || 0})</h2>
      <p>Favoritos guardados: {favoritos.length}</p>
      {/* Renderizar usuarios... */}
    </div>
  );
}
```

## Mejores Prácticas

### 1. Reglas de los Hooks
- Siempre úsalos en el nivel superior
- No los uses dentro de loops, condiciones o funciones anidadas
- Solo úsalos en componentes de React o hooks personalizados

### 2. Dependencias en useEffect
```jsx
// ✅ Correcto
useEffect(() => {
  fetchData(userId);
}, [userId]);

// ❌ Incorrecto (falta dependencia)
useEffect(() => {
  fetchData(userId);
}, []);
```

### 3. Optimización Inteligente
```jsx
// Solo usa useMemo/useCallback cuando realmente lo necesites
// ✅ Bueno para cálculos costosos
const datosProcesados = useMemo(() => {
  return datosGrandes.map(procesarDatos);
}, [datosGrandes]);

// ❌ Innecesario para cálculos simples
const suma = useMemo(() => a + b, [a, b]);
```

## Conclusión

Los React Hooks proporcionan una forma poderosa y elegante de manejar estado y efectos secundarios en componentes funcionales. Dominar estos hooks te permitirá escribir código más limpio, reutilizable y fácil de mantener.

**Recomendaciones para continuar:**
1. Practica con cada hook individualmente
2. Crea tus propios hooks personalizados
3. Aprende sobre hooks más avanzados como useLayoutEffect
4. Explora librerías de hooks como react-use

¡Empieza a experimentar con estos ejemplos y verás cómo mejora tu código React!
