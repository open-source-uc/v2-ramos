---
title: "Git y GitHub: Flujo de Trabajo Colaborativo"
readtime: 6
description: "Aprende las mejores prácticas para trabajar en equipo con Git y GitHub. Desde comandos básicos hasta estrategias avanzadas de branching y code review."
author:
  name: "Carla Mendoza"
  title: "DevOps Engineer"
  picture: "https://images.unsplash.com/photo-1487412720507-e7ab37603c6f?w=150&h=150&fit=crop&crop=face"
  link: "https://github.com/carlamendoza"
tags:
  - git
  - github
  - version-control
  - colaboracion
  - devops
---

# Git y GitHub: Flujo de Trabajo Colaborativo

Git es el sistema de control de versiones más utilizado en el desarrollo de software, y GitHub es la plataforma que lo ha hecho accesible para millones de desarrolladores. Dominar estas herramientas es esencial para cualquier desarrollador moderno.

## Conceptos Fundamentales

### ¿Qué es Git?
Git es un sistema de control de versiones distribuido que permite:
- Rastrear cambios en archivos
- Colaborar con múltiples desarrolladores
- Mantener historial completo del proyecto
- Crear ramas para desarrollar características independientes

### Configuración Inicial
```bash
# Configurar identidad (obligatorio)
git config --global user.name "Tu Nombre"
git config --global user.email "tu.email@ejemplo.com"

# Configuraciones útiles
git config --global init.defaultBranch main
git config --global core.editor "code --wait"
git config --global pull.rebase false

# Ver configuración actual
git config --list
```

## Comandos Básicos

### Inicialización y Clonado
```bash
# Inicializar repositorio nuevo
git init

# Clonar repositorio existente
git clone https://github.com/usuario/proyecto.git

# Clonar con nombre específico
git clone https://github.com/usuario/proyecto.git mi-proyecto
```

### Área de Staging y Commits
```bash
# Ver estado del repositorio
git status

# Agregar archivos al staging area
git add archivo.js                 # Archivo específico
git add .                         # Todos los archivos modificados
git add src/                      # Directorio completo
git add "*.js"                    # Por patrón

# Commit con mensaje
git commit -m "Agregar funcionalidad de login"

# Commit con mensaje detallado
git commit -m "Título del commit

Descripción más detallada de los cambios realizados.
Puede incluir múltiples líneas y explicar el por qué
de los cambios, no solo el qué."

# Commit directo (skip staging)
git commit -am "Mensaje del commit"

# Modificar último commit
git commit --amend -m "Nuevo mensaje"
```

### Historial y Logs
```bash
# Ver historial básico
git log

# Log con formato personalizado
git log --oneline --graph --decorate

# Ver cambios específicos
git log --since="2 weeks ago"
git log --author="Carla"
git log --grep="fix"

# Ver diferencias
git diff                          # Working directory vs staging
git diff --staged                 # Staging vs último commit
git diff HEAD~1                   # Comparar con commit anterior
```

## Branching y Merging

### Gestión de Ramas
```bash
# Crear nueva rama
git branch feature/nueva-funcionalidad

# Crear y cambiar a nueva rama
git checkout -b feature/nueva-funcionalidad
# o con comando moderno:
git switch -c feature/nueva-funcionalidad

# Listar ramas
git branch                        # Ramas locales
git branch -r                     # Ramas remotas
git branch -a                     # Todas las ramas

# Cambiar de rama
git checkout main
git switch main                   # Comando moderno

# Eliminar rama
git branch -d feature/completada  # Solo si está mergeada
git branch -D feature/no-necesaria # Forzar eliminación
```

### Merging
```bash
# Merge simple
git checkout main
git merge feature/nueva-funcionalidad

# Merge con commit específico
git merge --no-ff feature/nueva-funcionalidad

# Merge squash (combina todos los commits en uno)
git merge --squash feature/muchos-commits
```

### Rebase
```bash
# Rebase interactivo para limpiar historial
git rebase -i HEAD~3

# Rebase rama feature sobre main actualizado
git checkout feature/mi-feature
git rebase main

# Continuar rebase después de resolver conflictos
git rebase --continue

# Abortar rebase
git rebase --abort
```

## Trabajando con Remotos

### Configuración de Remotos
```bash
# Ver remotos configurados
git remote -v

# Agregar remoto
git remote add origin https://github.com/usuario/proyecto.git

# Cambiar URL de remoto
git remote set-url origin https://github.com/nuevo-usuario/proyecto.git

# Eliminar remoto
git remote remove origin
```

### Push y Pull
```bash
# Push inicial
git push -u origin main

# Push normal
git push

# Push de nueva rama
git push -u origin feature/nueva-rama

# Pull cambios
git pull

# Pull con rebase
git pull --rebase

# Fetch (descargar sin merge)
git fetch origin
```

## Flujo de Trabajo Git Flow

Git Flow es una estrategia de branching muy popular:

### Ramas Principales
- **main/master**: Código en producción
- **develop**: Rama de desarrollo principal

### Ramas de Apoyo
- **feature/***: Nuevas características
- **hotfix/***: Correcciones urgentes
- **release/***: Preparación de releases

### Comandos Git Flow
```bash
# Inicializar git flow
git flow init

# Crear feature
git flow feature start nueva-funcionalidad

# Finalizar feature
git flow feature finish nueva-funcionalidad

# Crear release
git flow release start 1.2.0

# Finalizar release
git flow release finish 1.2.0

# Crear hotfix
git flow hotfix start critical-bug

# Finalizar hotfix
git flow hotfix finish critical-bug
```

## GitHub: Colaboración Efectiva

### Fork y Pull Requests

#### 1. Fork del Repositorio
```bash
# Fork en GitHub (botón Fork en la interfaz)
# Luego clonar tu fork
git clone https://github.com/tu-usuario/proyecto-forkeado.git

# Agregar upstream
git remote add upstream https://github.com/usuario-original/proyecto.git
```

#### 2. Mantener Fork Actualizado
```bash
# Sincronizar con upstream
git fetch upstream
git checkout main
git merge upstream/main
git push origin main
```

#### 3. Crear Pull Request
```bash
# Crear rama para tu contribución
git checkout -b fix/corregir-bug

# Hacer cambios y commits
git add .
git commit -m "Corregir bug en validación de formulario"

# Push de la rama
git push origin fix/corregir-bug

# Crear PR en GitHub (interfaz web)
```

### Mejores Prácticas para Pull Requests

#### Template de PR
```markdown
## Descripción
Breve descripción de los cambios realizados.

## Tipo de cambio
- [ ] Bug fix
- [ ] Nueva funcionalidad
- [ ] Breaking change
- [ ] Documentación

## ¿Cómo se ha probado?
- [ ] Tests unitarios
- [ ] Tests de integración
- [ ] Prueba manual

## Checklist
- [ ] Mi código sigue las convenciones del proyecto
- [ ] He realizado self-review de mi código
- [ ] He agregado tests que prueban mi fix/feature
- [ ] Tests nuevos y existentes pasan localmente
```

## Resolución de Conflictos

### Conflictos en Merge
```bash
# Cuando hay conflicto, Git marca los archivos
git status

# Abrir archivos con conflictos y resolverlos manualmente
# Buscar marcadores como:
# <<<<<<< HEAD
# Código de la rama actual
# =======
# Código de la rama que se está mergeando
# >>>>>>> feature/nueva-rama

# Después de resolver
git add archivo-resuelto.js
git commit -m "Resolver conflicto de merge"
```

### Herramientas para Conflictos
```bash
# Configurar herramienta de merge
git config --global merge.tool vscode

# Usar herramienta visual
git mergetool

# Ver diferencias lado a lado
git diff --name-only --diff-filter=U
```

## Comandos Avanzados

### Cherry Pick
```bash
# Aplicar commit específico a rama actual
git cherry-pick abc123def

# Cherry pick múltiples commits
git cherry-pick abc123..def456
```

### Stash
```bash
# Guardar trabajo temporal
git stash

# Stash con mensaje
git stash save "Trabajo en progreso - funcionalidad X"

# Ver stashes
git stash list

# Aplicar último stash
git stash pop

# Aplicar stash específico
git stash apply stash@{1}

# Eliminar stash
git stash drop stash@{0}
```

### Reset y Revert
```bash
# Reset suave (mantiene cambios en staging)
git reset --soft HEAD~1

# Reset medio (mantiene cambios en working directory)
git reset --mixed HEAD~1

# Reset duro (elimina todos los cambios)
git reset --hard HEAD~1

# Revert (crear commit que deshace cambios)
git revert abc123def
```

## Automatización con GitHub Actions

### Ejemplo de CI/CD Básico
```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run tests
      run: npm test
    
    - name: Run linter
      run: npm run lint
```

## Mejores Prácticas

### 1. Commits Semánticos
```bash
# Formato: tipo(scope): descripción
feat(auth): agregar login con Google
fix(api): corregir validación de email  
docs(readme): actualizar instrucciones de instalación
style(css): corregir indentación en componentes
refactor(utils): simplificar función de validación
test(auth): agregar tests para login
chore(deps): actualizar dependencias
```

### 2. Flujo de Trabajo Recomendado
1. **Crear rama** para cada feature/fix
2. **Commits pequeños** y frecuentes
3. **Push regular** para respaldar trabajo
4. **Pull request** para code review
5. **Merge** después de aprobación
6. **Eliminar rama** después del merge

### 3. Protección de Ramas
- Configurar branch protection rules
- Requerir reviews antes de merge
- Ejecutar checks automáticos
- Restringir push directo a main

## Herramientas Complementarias

### GitHub CLI
```bash
# Instalar GitHub CLI
# https://cli.github.com/

# Autenticarse
gh auth login

# Crear repo
gh repo create mi-proyecto --public

# Crear PR desde línea de comandos
gh pr create --title "Nueva funcionalidad" --body "Descripción"

# Ver PRs
gh pr list

# Revisar PR
gh pr checkout 123
gh pr review --approve
```

### Git Aliases Útiles
```bash
# Configurar aliases
git config --global alias.st status
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.cm commit
git config --global alias.lg "log --oneline --graph --decorate"
git config --global alias.unstage "reset HEAD --"
```

## Conclusión

Dominar Git y GitHub es fundamental para el desarrollo colaborativo moderno. Estas herramientas no solo te permiten gestionar código de manera eficiente, sino que también facilitan la colaboración con equipos distribuidos globalmente.

**Recomendaciones finales:**
- Practica con proyectos personales
- Contribuye a proyectos open source
- Usa herramientas visuales cuando empiezas
- Aprende gradualmente comandos más avanzados
- Mantente actualizado con nuevas características

¡El control de versiones es una habilidad que mejorarás toda tu carrera como desarrollador!
